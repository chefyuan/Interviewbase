---
lang: zh-CN
title: 5、持久化
description: 很细。
---




# 5.Redis 持久化

Redis主要通过两种方法实现持久化，一种是RDB持久化，一种是AOF 持久化，下面详细说一下两种持久化机制

<p id="RDB持久化"></p>


## 5.0 RDB 持久化

因为Redis整个加载都在内存中，所以我们可以通过RDB持久化将内容中的数据保存到内存中去，避免数据丢失。

RDB 持久化可以手动执行，也可以定期自动执行。不过AOF 的更新频率更高，当开启AOF持久化时，会优先使用AOF文件来还原持久化。

![img](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221554820.png)

Redis中主要有两个命令生成Redis的RDB 文件，一个是SAVE,一个是BGSAVE文件。

其中SAVE文件会堵塞Redis服务器进程，直到文件创建完毕（不好用），`BGSAVE会派生出一个子进程来进行创建文件。`

另外需要注意的是，RDB文件的话，会随着数据量越来越大，数据量太大时，则会加大生成快照的难度。

但是我们思考一下，我们生成RDB的过程中，如果有数据发生了更改该怎么办呢？

fork 出的子进程用于生成RDB文件，然后在生成过程中，如果有写操作，则让主进程将这块数据复制一份，在复制份上进行写。

我们可以通过使用命令，设置BGSAVE每隔一段时间执行。但是这个时间设置多大，是一件比较困难的事。

所以我们采用`增量快照`

制作一次全局快照之后，后续将修改的值，补写入全局快照即可。

但是我们单独记录的话， 修改的数据是身份庞大的，所以我们可以采用 AOF 和 RDB 结合的方法来搞定。使用AOF 来记录这块修改的内容。

<p id="文件结构"></p>


### 5.1 RDB文件结构



REDIS


db_version


database


EOF


check_sum

REDIS:判读是否是Redis文件

db_version:代表RDB文件的版本

database:代表对几号数据库进行保存。

EOF：代表正文部分结束

check_sum：根据前几项求得的校验和

每个非空数据库在RDB文件中都可以保存为



SELECTDB


db_number


key_value_pairs

SELECTDB:表示将要读一个数据库号码。

db_number：代表数据库的号码。

key_value_pairs内容

<p id="AOF持久化"></p>


## 5.2 AOF持久化

优点：AOF写后日志，他是数据写完之后才写入日志中，这种不会影响写操作。写前日志WAL

缺点：

- 有可能会缺失日志，那就是当AOF 还没来的及写的时候发生宕机，则会造成缺失日志的情况。

- 另一种情况则是会影响下次写入操作

AOF三种写入磁盘时机

同步写回：发生写操作之后，立马写入磁盘中

每秒写回：每秒写入一次

操作系统控制写回：

![img](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221554262.png)

<p id="AOF重写"></p>


### 5.3 AOF重写

AOF重写的含义是将多条语句合并成一条，AOF写入是以追加的形式来的，重写就是保证其最新状态。

AOF的重写过程是由子线程来完成的，另外重写过程是这样的，子线程会拷贝主线程的内存，然后进行重写，这时如果有写操作继续执行的话，则放入缓冲区内，会同时放入重写缓冲区和写入缓冲区。

这时我们又有问题了，为什么不让父子进程同时写一个文件，因为这样会产生竞争，然后我们处理竞争又会影响速度。

推荐阅读：https://www.cnblogs.com/xuanyuan/p/13689484.html
