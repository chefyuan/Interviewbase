---
lang: zh-CN
title: 2、其他常考
description: Java 垃圾回收算法。

category:

    - JVM
    - 垃圾回收
    - CMS
    - 回收算法
    - 程序厨

excerpt: JVM 垃圾收集器，CMS、垃圾回收
---



# 3、其他常考

<p id="垃圾回收算法"></p>

## 3.0 垃圾回收算法

`标记-清除算法`

原理和名字一样，首先标记出需要回收的对象，标记完成后，统一回收掉所有被标记的对象。

缺点：不稳定，效率低，内存空间碎片化，会产生没有连续内存的情况，无法分配给新的对象。

`标记-复制算法`

 每次分配两块内存，先使用一块，当某一块快用完的时候，就将这一块存活的对象回收到另一块中。

缺点：如果有大量存活的时候，则需要大量的内存开销，每次都是针对半区进行回收，然后就会将可用内存缩小为原来的一半。appel 分配担保机制，以 9 ：1的比例进行标记复制，9的用于分配内存，1用来复制存活的对象，另外当1不足以容纳一次的时候，就需要依赖其他内存区域，分配担保。

用于新生代，老年代一般不使用

`标记-整理算法`

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221713774)

<p id="判断对象回收方法"></p>


## 3.1 两种判断对象死亡的方法

可达性分析：

原理：首先从GC Roots的对象作为起点开始，然后向下搜索，搜索走过的路径称为引用链，如果一个对象没有任何引用链相连，则判断为对象不可用，作为可回收对象，通过finalize()自救。

优缺点：解决相互循环引用问题

`这个算法的核心思路就是通过一些列的“GC Roots”对象作为起始点，从这些对象开始往下搜索，搜索所经过的路径称之为“引用链`”。

当一个对象到GC Roots没有任何引用链相连的时候，证明此对象是可以被回收的。如下图所示：

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221713930.jpg)

在Java中，可作为GC Roots对象的列表：

- Java虚拟机栈中的引用对象。

- 本地方法栈中JNI（既一般说的Native方法）引用的对象。

- 方法区中类静态常量的引用对象。

- 方法区中常量的引用对象。

引用计数法：

原理：有一个地方引用对象，则此对象计数器 +1，引用失效则-1，计数器为0则不能使用

优缺点：判断效率高，实现简单，但是难以解决对象互相循环引用问题




