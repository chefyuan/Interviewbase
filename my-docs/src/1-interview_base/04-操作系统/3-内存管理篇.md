---
lang: zh-CN
title: 3、内存管理篇
description: 很细。
---


# 3.内存管理篇

## 基础概述

<p id="内存管理的功能"></p>


## 3.0 内存管理的功能？

`内存的分配和回收`

`地址变换`：程序的逻辑地址和内存中的物理地址不一致，提供地址变换功能，将逻辑地址变为物理地址

`扩充内存`：借助虚拟存储技术，为用户提供比内存大的内存空间

`存储保护`：各个进程之间互不干扰。

<p id="虚拟地址和物理"></p>


## 3.1 虚拟地址和物理地址

虚拟地址：MMU经过转换之后制造出来的内存空间

物理地址：是虚拟地址变换后的最终地址，实打实存在的，可以根据物理地址从主存中获取

我们通过一个小例子来加深理解

打个比方，你有一本笔记本，每页都有页码，现在是空的，你可以在上边记东西。你要上语文数学英语三门课，三门课的笔记要记在基本上。显然，这三门课是混着上的，所以如果你从前往后记笔记，这三门课的内容是混起来的。

你需要不时翻找每门课的笔记，但是因为内容都是混在一起的，查找很困难，所以你想到了一个办法：记笔记的时候，记语文的页只记语文，不把其他课的内容混在一起。并且用单独的三页记录每门课的笔记的页码。你管这种记录方式叫做页表。笔记每多记一页，就在相应的学科的页表上记上笔记本页数。

于是你需要找语文第10页的时候，只要看语文的页表，发现语文第10页放在笔记本的第20页上，那么你只要翻到笔记本第20页就能看到你想要的内容了。

在这个例子中：

笔记本 -- 物理内存

笔记本页码 -- 物理地址

笔记页 -- 页框 (Page frame)

页表 -- 页表 (Page table)

页表内容 -- 页表项 (Page table entry)

语文页码 -- 虚拟地址

推荐阅读：https://www.zhihu.com/question/25105320/answer/402603264

<p id="覆盖和交换"></p>


## 3.2 覆盖和交换？

`覆盖技术`，就是把一个大程序划分为一系列覆盖，每个覆盖是相对独立的程序单位。把不要求同时装入内存的覆盖组成一组，称为覆盖段。

覆盖打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行。

`交换技术`，交换技术就是`把暂时不用的某个程序及数据部分`，从内存移到外存中，以便腾出必要的内存空间。但是运行程序的大小，仍然受内存大小限制。

<p id="内存分配方式"></p>


## 3.3 内存分配方式　

`连续分配`

`单一连续分配`

古老的操作系统，只分配一个作业到内存中，用不了的则浪费了。

这样会产生内部碎片，内部碎片的含义也很容易理解，用不了的地方，浪费了，外部碎片，还剩一点但是不足以再进行分配。

`固定分区分配`

比单一分配进步一点，但是给内存分块，然后进行分配，块的大小可以是固定的，也可以是不固定的。这样就可以在内存中分配多个作业，但是同样会产生内存碎片。

`动态分区分配`

不事先建好分区，在内存分配的过程中动态建立分区。通过空闲分区表来进行分配。

主要由有四种方法

首次适应：根据地址从小到达进行搜索，直到搜索到合适的位置。

最佳适应：将空闲分区容量，按从小到大的方式进行排序，找到合适的则进行分配

最坏适应：将空闲分区容量，按照从大到小的方式进行排序，找到合适的则进行分配。

邻近适应：是一个循环队列，不每次都从头部开始寻找，而是循环查找，直到查找到合适的地方。

`非连续分配方式`

非连续分配方式也很容易理解，将内存分为很多块，并创建一个页表进行保存页号和块号，类似于哈希表，可以直接通过页表，查找到程序页在内存的哪个块中。

但是这样有一个弊端，那就是需要多次访问内存，会让访问速度降低，所以我们引入快表机制，快表又叫联想寄存器，容量很小，用于保存经常访问的块号和页号。这因为有快表，所以页表总被称之为慢表。

推荐阅读：https://zhuanlan.zhihu.com/p/152119007

<p id="虚拟内存"></p>


## 3.4 虚拟内存

之前说到的内存分配方法，存在这两种情况，一次性（完全存入内存才可执行），驻留性（作业长驻内存直到运行结束）一个程序中，有的代码执行很少，程序所访问的空间也很局限。

虚拟内存管理技术就是`能够让作业部分装入就可以运行`的存储管理技术

<p id="虚拟内存方式"></p>


## 3.5 虚拟内存实现方式

程序装入时，将程序的一部分放入内存，而将其余部分放在外存，这时启动程序，边执行边把所需的部分调入内存。另一方面，操作系统将内存中暂时不用的放到外存中，从而腾出空间。这样看，操作系统为用户提供了一个存储容量比实际内存大的多的存储器。

虚拟内存的特征

离散性：内存中离散存储（不是专有）

多次性：多次放入

交换性：可以和暂时不用的页进行交换

虚拟性：让人觉得比实际大得多

顺便在这里提一嘴缺页中断，当内存中没有需要的页时，则会产生一个缺页中断，然后去外存中找到，并交换到内存中。

推荐阅读：https://zhuanlan.zhihu.com/p/96098896

<p id="页面置换"></p>


## 3.6 页面置换算法

`最佳页面置换`：每次淘汰以后不再使用的或以后最迟使用的页面

`先进先出`

`最近最少使用`

`时钟置换算法`

当发生缺页中断时，算法首先检查表针指向的页面：

- 如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；

- 如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；

![image-20211012154534698](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221630416.png)

![image-20211012155025662](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221630659.png)

`最不常用算法`

`页面缓冲算法`

推荐阅读：https://zhuanlan.zhihu.com/p/225162322

<p id="管理方式"></p>


## 3.7 管理方式

在操作系统中，进程是以页为单位加载到内存中的，按需分页是一种`虚拟内存`的管理方式。在使用请求分页的系统中，只有在尝试访问页面所在的磁盘并且该页面尚未在内存中时，也就发生了`缺页异常`，操作系统才会将磁盘页面复制到内存中。

<p id="抖动和缺页率"></p>


## 3.8 抖动和缺页率

`抖动`：若选用的置换算法不合适，可能会出现这种现象，刚被淘汰的页面，过后不久又要访问，调入不久又调出，如此反复，使得大部分时间用在页面的调入调出上，几乎不能完成有效的工作。

`缺页率`：也就是进行页面交换的次序。

belady异常：随着分配物理块数的增加而增加，这种奇怪的现象就是belady异常。
