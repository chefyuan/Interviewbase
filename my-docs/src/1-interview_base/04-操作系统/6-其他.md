---
lang: zh-CN
title: 6、其他
description: 很细。
---



# 6.其他补充

<p id="用户和内核"></p>


## 6.1 什么是用户态和内核态 

核心态：又指管态、系统态，是操作系统`管理程序执行时`机器所处的状态。具有较高特权，能执行一切指令。

用户态：是用户程序执行时机器所处的状态，特权较低，只能执行规定内的指令，访问指定的部分。

总结：核心态特权高，可以横行霸道，拥有一切特权，执行指令，访问内存。用户态特权小，只能执行部分指令，访问部分内存。

另外`用户不能直接调用核心态程序，只能通过中断，由中断系统将其转入操作系统内的相应程序。`

特权指令：只能有操作系统内核部分使用，不允许用户直接使用的指令，I/0指令。设置中断屏蔽指令、清内存指令，存储保护指令，设置时钟指令。

推荐阅读：https://zhuanlan.zhihu.com/p/388057431

<p id="中断和异常"></p>


## 6.2 中断和异常

中断：又称为外中断，是系统正常功能的一部分，使系统停止当前运行的进程而执行其他进程。然后操作系统处理完该任务之后，再来处理中断前的命令。

异常：是由错误引起的，如文件损坏、进程越界等。

<p id="同步机制"></p>


## 6.3 Linux 的同步机制

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221635338.png)

- 同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等；

- 互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」；

可以使用互斥锁

<p id="虚拟技术"></p>


## 6.4 虚拟技术你了解吗？

就是把物理实体转化为逻辑实体 

主要有两种虚拟技术：时分复用技术和空分复用技术

<p id="IO多路复用"></p>


## 6.5 什么是I/O多路复用？

[https://zhuanlan.zhihu.com/p/358208161](https://zhuanlan.zhihu.com/p/358208161)

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221635711.png)

通过线程池来处理已连接的 socket

![image-20211012160142144](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221635892.png)

这是一个全局队列，然后调用之前需要加锁。

I/O多路复用

一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，**这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用** 。

select / poll / epoll 

![image-20211012161016479](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221635355.png)

边缘触发：提醒一次

水平触发：没有做，就一直提醒。

<p id="大端小端"></p>


## 6.6 大端小端

这里我们先说一下用8位16进制，描述32位二进制数，这里有两种说法为什么可以表示

一种是16等于 2 的 4 次方，刚好可以表示

另一种是 0000-1111刚好为16。

所以我们经常用 8 位 16 进制来表述 32 位 2 进制数。

然后一个字节是 8 位，那么两位 16 进制数则为 一个字节。

大端模式：高位字节放在内存的低地址端，低字节位放在内存的高地址端

小端模式：高位字节放在内存的高地址端，低字节位放在内存的低地址端。

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221635538.png)

另外我们应该如何检测是大端模式还是小端模式呢？

使用C语言的 union 共同体

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221635607.png)

```JavaScript
#include <stdio.h>
int main()
{
    union{
      int a;  //4 bytes
      char b; //1 byte
    } data;
  
    data.a = 1; //占4 bytes，十六进制可表示为 0x 00 00 00 01

    //b因为是char型只占1Byte，a因为是int型占4Byte
    //所以，在联合体data所占内存中，b所占内存等于a所占内存的低地址部分 
    if(1 == data.b){ //走该case说明a的低字节，被取给到了b，即a的低字节存在了联合体所占内存的(起始)低地址，符合小端模式特征
      printf("Little_Endian\n");
     } else {
      printf("Big_Endian\n");
     }
   return 0;
}
```


如果 b = 1 那么则为小端存储，低字节位存在低地址位。

<p id="零拷贝"></p>

## 6.7 什么是零拷贝？

推荐阅读：https://zhuanlan.zhihu.com/p/258513662

<p id="BNA"></p>


## 6.8 BIO（同步阻塞）、NIO（同步非阻塞）、AIO（异步非阻塞）

BIO堵塞IO：发现被使用，则一直等待

NIO：发现被使用，先去干别的，然后每隔一段时间再回来，然后看看用完没。

AIO：发现被使用，先去干别的，等结束了我通知你，你再回来



